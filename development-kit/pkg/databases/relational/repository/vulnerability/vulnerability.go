// Copyright 2020 ZUP IT SERVICOS EM TECNOLOGIA E INOVACAO SA
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package vulnerability

import (
	SQL "github.com/ZupIT/horusec/development-kit/pkg/databases/relational"
	"github.com/ZupIT/horusec/development-kit/pkg/entities/api/dto"
	"github.com/ZupIT/horusec/development-kit/pkg/entities/horusec"
	horusecEnums "github.com/ZupIT/horusec/development-kit/pkg/enums/horusec"
	"github.com/ZupIT/horusec/development-kit/pkg/enums/severity"
	"github.com/ZupIT/horusec/development-kit/pkg/utils/pagination"
	"github.com/google/uuid"
	"github.com/jinzhu/gorm"
)

type IRepository interface {
	ListVulnManagementData(repositoryID uuid.UUID, page, size int, vulnSeverity severity.Severity,
		vulnType horusecEnums.VulnerabilityType, vulnHash string) (vulnManagement dto.VulnManagement, err error)
	UpdateVulnType(vulnerabilityID uuid.UUID,
		updateTypeData *dto.UpdateVulnType) (*horusec.Vulnerability, error)
	GetVulnByID(vulnerabilityID uuid.UUID) (*horusec.Vulnerability, error)
}

type Repository struct {
	databaseRead  SQL.InterfaceRead
	databaseWrite SQL.InterfaceWrite
}

func NewManagementRepository(databaseRead SQL.InterfaceRead, databaseWrite SQL.InterfaceWrite) IRepository {
	return &Repository{
		databaseRead:  databaseRead,
		databaseWrite: databaseWrite,
	}
}

func (r *Repository) ListVulnManagementData(repositoryID uuid.UUID, page, size int, vulnSeverity severity.Severity,
	vulnType horusecEnums.VulnerabilityType, vulnHash string) (vulnManagement dto.VulnManagement, err error) {
	query := r.databaseRead.GetConnection().Raw("SELECT * FROM ? AS tmpTable"+
		" ORDER BY CASE tmpTable.severity"+
		" WHEN 'HIGH' THEN 1 WHEN 'MEDIUM' THEN 2 WHEN 'LOW' THEN 3 WHEN 'AUDIT' THEN 4"+
		" WHEN 'INFO' THEN 5 END, tmpTable.type DESC LIMIT ? OFFSET ?",
		r.listVulnManagementDataSubQuery(repositoryID, vulnSeverity, vulnType, vulnHash),
		size, pagination.GetSkip(int64(page), int64(size)))

	vulnManagement.TotalItems = r.getTotalVulnManagementData(repositoryID, vulnSeverity, vulnType, vulnHash)
	return vulnManagement, query.Find(&vulnManagement.Data).Error
}

func (r *Repository) getTotalVulnManagementData(repositoryID uuid.UUID,
	vulnSeverity severity.Severity, vulnType horusecEnums.VulnerabilityType, vulnHash string) (count int) {
	query := r.databaseRead.
		GetConnection().
		Select("COUNT( DISTINCT ( vulnerabilities.vulnerability_id ) )").
		Table("analysis").
		Joins("JOIN analysis_vulnerabilities ON analysis.analysis_id = analysis_vulnerabilities.analysis_id").
		Joins("JOIN vulnerabilities ON vulnerabilities.vulnerability_id = analysis_vulnerabilities.vulnerability_id")

	_ = r.setWhereFilter(query, repositoryID, vulnSeverity, vulnType, vulnHash).Count(&count)
	return count
}

// nolint
func (r *Repository) setWhereFilter(query *gorm.DB, repositoryID uuid.UUID, vulnSeverity severity.Severity,
	vulnType horusecEnums.VulnerabilityType, vulnHash string) *gorm.DB {
	if vulnHash != "" && vulnSeverity != "" && vulnType != "" {
		return query.Where("repository_id = ? AND vulnerabilities.severity = ? AND vulnerabilities.type = ?"+
			" AND vulnerabilities.vuln_hash ~ ?", repositoryID, vulnSeverity, vulnType, vulnHash)
	}

	if vulnHash != "" && vulnSeverity != "" {
		return query.Where("repository_id = ? AND vulnerabilities.severity = ? AND vulnerabilities.vuln_hash ~ ?",
			repositoryID, vulnSeverity, vulnHash)
	}

	if vulnHash != "" && vulnType != "" {
		return query.Where("repository_id = ? AND vulnerabilities.type = ? AND vulnerabilities.vuln_hash ~ ?",
			repositoryID, vulnType, vulnHash)
	}

	if vulnSeverity != "" && vulnType != "" {
		return query.Where("repository_id = ? AND vulnerabilities.type = ? AND vulnerabilities.severity = ?",
			repositoryID, vulnType, vulnSeverity)
	}

	if vulnHash != "" {
		return query.Where("repository_id = ? AND vulnerabilities.vuln_hash ~ ?", repositoryID, vulnHash)
	}

	if vulnSeverity != "" {
		return query.Where("repository_id = ? AND vulnerabilities.severity = ?", repositoryID, vulnSeverity)
	}

	if vulnType != "" {
		return query.Where("repository_id = ? AND vulnerabilities.type = ?", repositoryID, vulnType)
	}

	return query.Where("repository_id = ?", repositoryID)
}

func (r *Repository) UpdateVulnType(vulnerabilityID uuid.UUID,
	updateTypeData *dto.UpdateVulnType) (*horusec.Vulnerability, error) {
	toUpdate, err := r.GetVulnByID(vulnerabilityID)
	if err != nil {
		return nil, err
	}

	toUpdate.SetType(updateTypeData.Type)
	return toUpdate, r.databaseWrite.Update(toUpdate,
		map[string]interface{}{"vulnerability_id": vulnerabilityID}, toUpdate.GetTable()).GetError()
}

func (r *Repository) GetVulnByID(vulnerabilityID uuid.UUID) (*horusec.Vulnerability, error) {
	vulnerability := &horusec.Vulnerability{}

	response := r.databaseRead.Find(vulnerability,
		r.databaseRead.SetFilter(map[string]interface{}{"vulnerability_id": vulnerabilityID}), vulnerability.GetTable())

	return vulnerability, response.GetError()
}

func (r *Repository) listVulnManagementDataSubQuery(repositoryID uuid.UUID,
	vulnSeverity severity.Severity, vulnType horusecEnums.VulnerabilityType, vulnHash string) *gorm.SqlExpr {
	query := r.databaseRead.GetConnection().
		Select("DISTINCT ON (vulnerabilities.vulnerability_id) vulnerabilities.vulnerability_id," +
			" vulnerabilities.type, vulnerabilities.vuln_hash, vulnerabilities.line, vulnerabilities.column," +
			" vulnerabilities.confidence, vulnerabilities.file, vulnerabilities.code, vulnerabilities.details," +
			" vulnerabilities.security_tool, vulnerabilities.language, vulnerabilities.severity").
		Table("analysis").
		Joins("JOIN analysis_vulnerabilities ON analysis.analysis_id = analysis_vulnerabilities.analysis_id").
		Joins("JOIN vulnerabilities ON vulnerabilities.vulnerability_id = analysis_vulnerabilities.vulnerability_id")

	return r.setWhereFilter(query, repositoryID, vulnSeverity, vulnType, vulnHash).SubQuery()
}
